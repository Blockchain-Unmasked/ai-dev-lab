#!/usr/bin/env python3
"""
AI/DEV Lab Web Application - Main FastAPI Application
Following OCINT architecture standards and security requirements.

This application demonstrates the integration of AI/DEV Lab systems
(MCP server, Cursor dual-mode, Guardian security) while implementing
established OCINT architectural patterns.
"""

import logging
import os
from contextlib import asynccontextmanager
from typing import Dict, Any

from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.security import HTTPBearer
import structlog

from .core.config import config
from .core.database import init_database, close_database
from .core.security import verify_token
from .api.routes import api_router
from .api.static_routes import static_router
from .core.logging import setup_logging

# Security token bearer
security = HTTPBearer()

# Setup structured logging following OCINT standards
setup_logging()
logger = structlog.get_logger()

# Global settings
settings = config

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan management following OCINT standards."""
    # Startup
    logger.info("Starting AI/DEV Lab Web Application")
    logger.info("Following OCINT architecture standards")
    
    # Initialize database connections
    await init_database()
    logger.info("Database connections initialized")
    
    # Initialize MCP server integration
    logger.info("MCP server integration ready")
    
    yield
    
    # Shutdown
    logger.info("Shutting down AI/DEV Lab Web Application")
    await close_database()
    logger.info("Database connections closed")

# Create FastAPI application with OCINT-compliant configuration
app = FastAPI(
    title="AI/DEV Lab Web Application",
    description="Built according to OCINT architecture standards and development practices",
    version="1.0.0",
    docs_url="/docs" if settings.APP_ENV == "development" else None,
    redoc_url="/redoc" if settings.APP_ENV == "development" else None,
    lifespan=lifespan
)

# Root endpoint - Serve the frontend HTML
@app.get("/")
async def root():
    """Root endpoint serves the main frontend application"""
    try:
        with open("/Users/hazael/Code/ai-dev-lab/app/frontend/index.html", "r") as f:
            content = f.read()
        return HTMLResponse(content=content)
    except Exception as e:
        logger.error(f"Failed to serve frontend: {e}")
        raise HTTPException(status_code=500, detail="Frontend not available")

# Asset serving from root path (CSS, JS, images)
@app.get("/assets/{file_path:path}")
async def serve_assets(file_path: str):
    """Serve frontend assets from /assets/ path"""
    try:
        full_path = f"/Users/hazael/Code/ai-dev-lab/app/frontend/assets/{file_path}"
        
        # Security: Prevent directory traversal
        if not full_path.startswith("/Users/hazael/Code/ai-dev-lab/app/frontend/assets/"):
            raise HTTPException(status_code=403, detail="Access denied")
        
        # Check if file exists
        if not os.path.exists(full_path) or not os.path.isfile(full_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        # Determine content type
        if file_path.endswith('.css'):
            content_type = 'text/css'
        elif file_path.endswith('.js'):
            content_type = 'application/javascript'
        elif file_path.endswith('.png'):
            content_type = 'image/png'
        elif file_path.endswith('.jpg') or file_path.endswith('.jpeg'):
            content_type = 'image/jpeg'
        elif file_path.endswith('.ico'):
            content_type = 'image/x-icon'
        else:
            content_type = 'text/plain'
        
        # Read and return file
        with open(full_path, 'rb') as f:
            content = f.read()
        
        from fastapi.responses import Response
        return Response(content=content, media_type=content_type)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to serve asset: {e}")
        raise HTTPException(status_code=500, detail="Error serving asset")

# Scripts serving from root path
@app.get("/scripts/{file_path:path}")
async def serve_scripts(file_path: str):
    """Serve frontend scripts from /scripts/ path"""
    try:
        full_path = f"/Users/hazael/Code/ai-dev-lab/app/frontend/scripts/{file_path}"
        
        # Security: Prevent directory traversal
        if not full_path.startswith("/Users/hazael/Code/ai-dev-lab/app/frontend/scripts/"):
            raise HTTPException(status_code=403, detail="Access denied")
        
        # Check if file exists
        if not os.path.exists(full_path) or not os.path.isfile(full_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        # Read and return file
        with open(full_path, 'rb') as f:
            content = f.read()
        
        from fastapi.responses import Response
        return Response(content=content, media_type='application/javascript')
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to serve script: {e}")
        raise HTTPException(status_code=500, detail="Error serving script")

# API information endpoint
@app.get("/api/info")
async def api_info() -> Dict[str, Any]:
    """API information endpoint with application details."""
    return {
        "application": "AI/DEV Lab Web Application",
        "description": "Built according to OCINT architecture standards",
        "version": "1.0.0",
        "documentation": "/docs" if settings.APP_ENV == "development" else None,
        "health_check": "/health",
        "architecture": {
            "frontend": "Vanilla JS + Web Components + Custom CSS Design System",
            "backend": "Python FastAPI + SQLite + SQLAlchemy",
            "security": "Guardian MCP + OCINT Standards",
            "ai_integration": "Gemini models through MCP server"
        }
    }

# Frontend serving endpoints (kept for backward compatibility)
@app.get("/frontend")
async def serve_frontend():
    """Serve the main frontend application"""
    try:
        with open("/Users/hazael/Code/ai-dev-lab/app/frontend/index.html", "r") as f:
            content = f.read()
        return HTMLResponse(content=content)
    except Exception as e:
        logger.error(f"Failed to serve frontend: {e}")
        raise HTTPException(status_code=500, detail="Frontend not available")

@app.get("/frontend/{file_path:path}")
async def serve_frontend_file(file_path: str):
    """Serve frontend assets (CSS, JS, images)"""
    try:
        full_path = f"/Users/hazael/Code/ai-dev-lab/app/frontend/{file_path}"
        
        # Security: Prevent directory traversal
        if not full_path.startswith("/Users/hazael/Code/ai-dev-lab/app/frontend/"):
            raise HTTPException(status_code=403, detail="Access denied")
        
        # Check if file exists
        if not os.path.exists(full_path) or not os.path.isfile(full_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        # Determine content type
        if file_path.endswith('.css'):
            content_type = 'text/css'
        elif file_path.endswith('.js'):
            content_type = 'application/javascript'
        elif file_path.endswith('.png'):
            content_type = 'image/png'
        elif file_path.endswith('.jpg') or file_path.endswith('.jpeg'):
            content_type = 'image/jpeg'
        elif file_path.endswith('.ico'):
            content_type = 'image/x-icon'
        else:
            content_type = 'text/plain'
        
        # Read and return file
        with open(full_path, 'rb') as f:
            content = f.read()
        
        from fastapi.responses import Response
        return Response(content=content, media_type=content_type)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to serve frontend file: {e}")
        raise HTTPException(status_code=500, detail="Error serving file")

# Security middleware following OCINT standards
# Allow test hostnames in testing environment
if settings.APP_ENV == "testing":
    allowed_hosts = ["localhost", "127.0.0.1", "testserver", "test"]
else:
    allowed_hosts = ["localhost", "127.0.0.1"]

# Only add TrustedHostMiddleware if not in testing mode
if settings.APP_ENV != "testing":
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=allowed_hosts
    )

# CORS middleware for development
if settings.APP_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ALLOWED_ORIGINS,
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE"],
        allow_headers=["*"],
    )

# Global exception handler following OCINT security standards
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler with security-conscious error responses."""
    logger.error("Unhandled exception", 
                path=request.url.path,
                method=request.method,
                error=str(exc),
                exc_info=True)
    
    # Security: Don't expose internal error details in production
    if settings.APP_ENV == "production":
        return JSONResponse(
            status_code=500,
            content={"detail": "Internal server error"}
        )
    else:
        return JSONResponse(
            status_code=500,
            content={"detail": str(exc)}
        )

# Security middleware for token verification
async def verify_authentication(token: str = Depends(security)):
    """Verify authentication token following OCINT security standards."""
    try:
        payload = verify_token(token.credentials)
        return payload
    except Exception as e:
        logger.warning("Authentication failed", error=str(e))
        raise HTTPException(
            status_code=401,
            detail="Invalid authentication credentials"
        )

# Health check endpoint (no authentication required)
@app.get("/health")
async def health_check() -> Dict[str, Any]:
    """Health check endpoint following OCINT standards."""
    return {
        "status": "healthy",
        "application": "AI/DEV Lab Web Application",
        "architecture": "OCINT Standards Compliant",
        "version": "1.0.0",
        "environment": settings.APP_ENV
    }

# Security status endpoint (requires authentication)
@app.get("/security/status")
async def security_status(auth: Dict[str, Any] = Depends(verify_authentication)) -> Dict[str, Any]:
    """Security status endpoint following OCINT security standards."""
    return {
        "security_status": "active",
        "guardian_integration": "enabled",
        "mcp_server": "connected",
        "audit_logging": "enabled",
        "user": auth.get("sub"),
        "permissions": auth.get("permissions", [])
    }

# Include API routes
app.include_router(api_router)

# Include static routes for frontend assets
app.include_router(static_router)

if __name__ == "__main__":
    import uvicorn
    
    uvicorn.run(
        "main:app",
        host=settings.APP_HOST,
        port=settings.APP_PORT,
        reload=settings.APP_ENV == "development",
        log_level="info"
    )

# Frontend page routes
@app.get("/customer-chat.html")
async def serve_customer_chat():
    """Serve the customer chat interface"""
    try:
        with open("/Users/hazael/Code/ai-dev-lab/app/frontend/customer-chat.html", "r") as f:
            content = f.read()
        return HTMLResponse(content=content)
    except Exception as e:
        logger.error(f"Failed to serve customer chat: {e}")
        raise HTTPException(status_code=500, detail="Customer chat not available")

@app.get("/qa-dashboard.html")
async def serve_qa_dashboard():
    """Serve the QA dashboard interface"""
    try:
        with open("/Users/hazael/Code/ai-dev-lab/app/frontend/qa-dashboard.html", "r") as f:
            content = f.read()
        return HTMLResponse(content=content)
    except Exception as e:
        logger.error(f"Failed to serve QA dashboard: {e}")
        raise HTTPException(status_code=500, detail="QA dashboard not available")

@app.get("/simple-test.html")
async def serve_simple_test():
    """Serve the simple test interface"""
    try:
        with open("/Users/hazael/Code/ai-dev-lab/app/frontend/simple-test.html", "r") as f:
            content = f.read()
        return HTMLResponse(content=content)
    except Exception as e:
        logger.error(f"Failed to serve simple test: {e}")
        raise HTTPException(status_code=500, detail="Simple test not available")

# Images serving route (including favicon)
@app.get("/assets/images/{file_path:path}")
async def serve_images(file_path: str):
    """Serve frontend images from /assets/images/ path"""
    try:
        full_path = f"/Users/hazael/Code/ai-dev-lab/app/frontend/assets/images/{file_path}"
        
        # Security: Prevent directory traversal
        if not full_path.startswith("/Users/hazael/Code/ai-dev-lab/app/frontend/assets/images/"):
            raise HTTPException(status_code=403, detail="Access denied")
        
        # Check if file exists
        if not os.path.exists(full_path) or not os.path.isfile(full_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        # Determine content type
        if file_path.endswith('.ico'):
            content_type = 'image/x-icon'
        elif file_path.endswith('.png'):
            content_type = 'image/png'
        elif file_path.endswith('.svg'):
            content_type = 'image/svg+xml'
        elif file_path.endswith('.jpg') or file_path.endswith('.jpeg'):
            content_type = 'image/jpeg'
        else:
            content_type = 'image/png'  # Default to PNG
        
        # Read and return file
        with open(full_path, 'rb') as f:
            content = f.read()
        
        from fastapi.responses import Response
        return Response(content=content, media_type=content_type)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to serve image: {e}")
        raise HTTPException(status_code=500, detail="Error serving image")
